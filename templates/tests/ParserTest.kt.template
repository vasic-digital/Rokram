/*#######################################################
 *
 * SPDX-FileCopyrightText: 2025 Milos Vasic
 * SPDX-License-Identifier: Apache-2.0
 *
 * Unit tests for {{FORMAT_NAME}} parser
 *
 *########################################################*/
package digital.vasic.yole.format.{{FORMAT_PACKAGE}}

import digital.vasic.yole.format.FormatRegistry
import digital.vasic.yole.format.{{FORMAT_PACKAGE}}.{{FORMAT_CLASS}}Parser
import org.junit.Test
import org.assertj.core.api.Assertions.assertThat
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

/**
 * Unit tests for {{FORMAT_NAME}} format parser.
 *
 * Tests cover:
 * - Format detection by extension
 * - Basic parsing functionality
 * - Edge cases and error handling
 * - Empty input handling
 * - Special characters
 */
class {{FORMAT_CLASS}}ParserTest {

    private val parser = {{FORMAT_CLASS}}Parser()

    // ==================== Format Detection Tests ====================

    @Test
    fun `should detect {{FORMAT_NAME}} format by extension`() {
        val format = FormatRegistry.getByExtension("{{PRIMARY_EXTENSION}}")

        assertNotNull(format)
        assertThat(format.id).isEqualTo(FormatRegistry.ID_{{FORMAT_ID}})
        assertThat(format.name).isEqualTo("{{FORMAT_NAME}}")
    }

    @Test
    fun `should detect {{FORMAT_NAME}} format by filename`() {
        val format = FormatRegistry.detectByFilename("test{{PRIMARY_EXTENSION}}")

        assertNotNull(format)
        assertThat(format.id).isEqualTo(FormatRegistry.ID_{{FORMAT_ID}})
    }

    @Test
    fun `should support all {{FORMAT_NAME}} extensions`() {
        val extensions = listOf({{EXTENSIONS_LIST}})

        extensions.forEach { ext ->
            val format = FormatRegistry.getByExtension(ext)
            assertNotNull(format, "Extension $ext should be recognized")
            assertThat(format.id).isEqualTo(FormatRegistry.ID_{{FORMAT_ID}})
        }
    }

    // ==================== Basic Parsing Tests ====================

    @Test
    fun `should parse basic {{FORMAT_NAME}} content`() {
        val content = """
            {{SAMPLE_CONTENT}}
        """.trimIndent()

        val result = parser.parse(content)

        assertNotNull(result)
        // Add format-specific assertions here
    }

    @Test
    fun `should handle empty input`() {
        val result = parser.parse("")

        assertNotNull(result)
        // Verify empty result is valid
    }

    @Test
    fun `should handle whitespace-only input`() {
        val result = parser.parse("   \n\n   \t  ")

        assertNotNull(result)
    }

    @Test
    fun `should handle single line input`() {
        val content = "{{SINGLE_LINE_SAMPLE}}"

        val result = parser.parse(content)

        assertNotNull(result)
    }

    // ==================== Content Detection Tests ====================

    @Test
    fun `should detect format by content patterns`() {
        val content = """
            {{SAMPLE_CONTENT}}
        """.trimIndent()

        val format = FormatRegistry.detectByContent(content)

        assertNotNull(format)
        assertThat(format.id).isEqualTo(FormatRegistry.ID_{{FORMAT_ID}})
    }

    @Test
    fun `should not false-positive on plain text`() {
        val plainText = "Just some plain text without special formatting"

        val format = FormatRegistry.detectByContent(plainText)

        // Should detect as plaintext, not {{FORMAT_NAME}}
        if (format != null) {
            assertThat(format.id).isNotEqualTo(FormatRegistry.ID_{{FORMAT_ID}})
        }
    }

    // ==================== Special Characters Tests ====================

    @Test
    fun `should handle special characters`() {
        val content = """
            {{SPECIAL_CHARS_SAMPLE}}
        """.trimIndent()

        val result = parser.parse(content)

        assertNotNull(result)
        // Verify special characters are preserved/escaped correctly
    }

    @Test
    fun `should handle unicode characters`() {
        val content = "Unicode test: ‰Ω†Â•Ω‰∏ñÁïå üåç –ü—Ä–∏–≤–µ—Ç –º–∏—Ä"

        val result = parser.parse(content)

        assertNotNull(result)
    }

    // ==================== Error Handling Tests ====================

    @Test
    fun `should handle malformed input gracefully`() {
        val malformed = """
            {{MALFORMED_SAMPLE}}
        """.trimIndent()

        // Should not throw exception
        val result = parser.parse(malformed)
        assertNotNull(result)
    }

    @Test
    fun `should handle very long input`() {
        val longContent = "{{SINGLE_LINE_SAMPLE}}\n".repeat(10000)

        val result = parser.parse(longContent)

        assertNotNull(result)
    }

    @Test
    fun `should handle null bytes gracefully`() {
        // Binary content detection
        val binaryContent = "Some text\u0000with null\u0000bytes"

        val result = parser.parse(binaryContent)

        assertNotNull(result)
    }

    // ==================== Format-Specific Tests ====================
    // Add format-specific parsing tests below
    // Examples:
    // - Headers (for Markdown, AsciiDoc, etc.)
    // - Lists (for Markdown, Org Mode, etc.)
    // - Code blocks (for Markdown, reStructuredText, etc.)
    // - Tables (for CSV, Markdown, etc.)
    // - Math (for LaTeX, R Markdown, etc.)

    @Test
    fun `should parse {{FORMAT_SPECIFIC_FEATURE}}`() {
        val content = """
            {{FORMAT_SPECIFIC_SAMPLE}}
        """.trimIndent()

        val result = parser.parse(content)

        assertNotNull(result)
        // Add format-specific assertions
    }

    // ==================== Integration Tests ====================

    @Test
    fun `should integrate with FormatRegistry`() {
        val format = FormatRegistry.getById(FormatRegistry.ID_{{FORMAT_ID}})

        assertNotNull(format)
        assertThat(format.name).isEqualTo("{{FORMAT_NAME}}")
        assertThat(format.defaultExtension).isEqualTo("{{PRIMARY_EXTENSION}}")
    }

    @Test
    fun `should be registered in FormatRegistry`() {
        val allFormats = FormatRegistry.formats
        val {{FORMAT_LOWERCASE}}Format = allFormats.find { it.id == FormatRegistry.ID_{{FORMAT_ID}} }

        assertNotNull({{FORMAT_LOWERCASE}}Format)
        assertThat({{FORMAT_LOWERCASE}}Format.name).isEqualTo("{{FORMAT_NAME}}")
    }
}
