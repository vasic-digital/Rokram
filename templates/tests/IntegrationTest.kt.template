/*#######################################################
 *
 * SPDX-FileCopyrightText: 2025 Milos Vasic
 * SPDX-License-Identifier: Apache-2.0
 *
 * Integration tests for {{FORMAT_NAME}} format
 *
 *########################################################*/
package digital.vasic.yole.format.{{FORMAT_PACKAGE}}

import digital.vasic.yole.format.FormatRegistry
import org.junit.Test
import org.assertj.core.api.Assertions.assertThat
import kotlin.test.assertNotNull

/**
 * Integration tests for {{FORMAT_NAME}} format.
 *
 * These tests verify the integration between:
 * - Format detection and parsing
 * - FormatRegistry and parser
 * - Parser and HTML conversion (if applicable)
 * - Cross-format compatibility
 */
class {{FORMAT_CLASS}}IntegrationTest {

    // ==================== Format Detection Integration ====================

    @Test
    fun `format detection should work with parser`() {
        val filename = "test{{PRIMARY_EXTENSION}}"
        val format = FormatRegistry.detectByFilename(filename)

        assertNotNull(format)
        assertThat(format.id).isEqualTo(FormatRegistry.ID_{{FORMAT_ID}})

        // Verify parser can be retrieved
        // val parser = ParserRegistry.getParser(format)
        // assertNotNull(parser)
    }

    @Test
    fun `content detection should match extension detection`() {
        val content = """
            {{SAMPLE_CONTENT}}
        """.trimIndent()

        val byContent = FormatRegistry.detectByContent(content)
        val byExtension = FormatRegistry.getByExtension("{{PRIMARY_EXTENSION}}")

        assertNotNull(byContent)
        assertNotNull(byExtension)
        assertThat(byContent.id).isEqualTo(byExtension.id)
    }

    // ==================== Cross-Format Tests ====================

    @Test
    fun `should not conflict with other formats`() {
        val formats = FormatRegistry.formats

        // Ensure {{FORMAT_NAME}} format is unique
        val {{FORMAT_LOWERCASE}}Formats = formats.filter { it.id == FormatRegistry.ID_{{FORMAT_ID}} }
        assertThat({{FORMAT_LOWERCASE}}Formats).hasSize(1)
    }

    @Test
    fun `should have unique extensions or share appropriately`() {
        val format = FormatRegistry.getById(FormatRegistry.ID_{{FORMAT_ID}})
        assertNotNull(format)

        format.extensions.forEach { ext ->
            val formatsForExt = FormatRegistry.getFormatsByExtension(ext)

            // Document which formats share extensions
            println("Extension $ext is used by: ${formatsForExt.map { it.name }}")

            // If extension is shared, verify we can distinguish by content
            if (formatsForExt.size > 1) {
                val sampleContent = """
                    {{SAMPLE_CONTENT}}
                """.trimIndent()

                val detected = FormatRegistry.detectByContent(sampleContent)
                assertNotNull(detected)
                // Should detect correctly even with shared extension
            }
        }
    }

    // ==================== Round-Trip Tests ====================

    @Test
    fun `should preserve content through parse cycle`() {
        val original = """
            {{SAMPLE_CONTENT}}
        """.trimIndent()

        val parser = {{FORMAT_CLASS}}Parser()
        val parsed = parser.parse(original)
        assertNotNull(parsed)

        // If format supports serialization back to text:
        // val serialized = parser.serialize(parsed)
        // assertThat(serialized).isEqualTo(original)
    }

    // ==================== File Operations Integration ====================

    @Test
    fun `should work with file-like operations`() {
        val content = """
            {{SAMPLE_CONTENT}}
        """.trimIndent()

        // Simulate file read -> parse -> process workflow
        val format = FormatRegistry.detectByFilename("document{{PRIMARY_EXTENSION}}")
        assertNotNull(format)

        val parser = {{FORMAT_CLASS}}Parser()
        val result = parser.parse(content)
        assertNotNull(result)
    }

    // ==================== Performance Tests ====================

    @Test
    fun `should handle large files efficiently`() {
        val largeContent = buildString {
            repeat(1000) {
                appendLine("{{SINGLE_LINE_SAMPLE}}")
            }
        }

        val parser = {{FORMAT_CLASS}}Parser()
        val startTime = System.currentTimeMillis()

        val result = parser.parse(largeContent)

        val duration = System.currentTimeMillis() - startTime

        assertNotNull(result)
        // Performance assertion - should parse 1000 lines in reasonable time
        assertThat(duration).isLessThan(1000) // 1 second max
    }

    @Test
    fun `should handle concurrent parsing`() {
        val content = """
            {{SAMPLE_CONTENT}}
        """.trimIndent()

        val parser = {{FORMAT_CLASS}}Parser()

        // Simulate concurrent access
        val results = (1..10).map {
            Thread {
                val result = parser.parse(content)
                assertNotNull(result)
            }
        }

        results.forEach { it.start() }
        results.forEach { it.join(5000) } // 5 second timeout

        // All threads should complete successfully
    }

    // ==================== Edge Case Integration ====================

    @Test
    fun `should handle mixed line endings`() {
        val content = "Line 1\nLine 2\r\nLine 3\rLine 4"

        val parser = {{FORMAT_CLASS}}Parser()
        val result = parser.parse(content)

        assertNotNull(result)
    }

    @Test
    fun `should handle different encodings`() {
        // UTF-8 content with various characters
        val content = """
            ASCII: Hello World
            Latin: Caf√© r√©sum√©
            Cyrillic: –ü—Ä–∏–≤–µ—Ç –º–∏—Ä
            Chinese: ‰Ω†Â•Ω‰∏ñÁïå
            Emoji: üåç üöÄ ‚ú®
        """.trimIndent()

        val parser = {{FORMAT_CLASS}}Parser()
        val result = parser.parse(content)

        assertNotNull(result)
    }
}
